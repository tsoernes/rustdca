use gridfuncs::*;
use ndarray::prelude::*;
use ordered_float::*;
use std::cmp::Ordering;
use std::collections::BinaryHeap;
use std::collections::HashMap;

pub struct CEvent {
    id: u32,
    time: f32,
    ce_type: CEType,
    cell: Cell,
    ch: usize,
    end_ch: usize,
}

// CEvent identifiers
struct CI {
    time: NotNaN<f32>,
    id: u32,
}

impl Ord for CI {
    // TODO revord
    fn cmp(&self, other: &CI) -> Ordering {
        self.time.cmp(&other.time)
    }
}

impl PartialOrd for CI {
    fn partial_cmp(&self, other: &CI) -> Option<Ordering> {
        Some(self.cmp(other))
    }
}

impl PartialEq for CI {
    fn eq(&self, other: &CI) -> bool {
        self.id == other.id
    }
}
impl Eq for CI {}

struct EventGen {
    call_dur: f32,
    hoff_call_dur: f32,
    // Min-heap of event-identifiers sorted on event times
    event_pq: BinaryHeap<CI>,
    // Mapping from event IDs to event structs
    events: HashMap<u32, CEvent>,
    // Mapping from cells to end event IDs
    end_times: HashMap<Cell, u32>,
}

impl EventGen {
    fn push(&mut self, event: CEvent) {
        if event.ce_type == CEType::END {
            self.end_times.insert(event.cell.clone(), event.id.clone());
        }
        unsafe {
            // 'event.time' was just generated by one of the 'event_*' functions
            // and cannot be NaN
            let t: NotNaN<f32> = NotNaN::unchecked_new(event.time.clone());
            self.event_pq.push(CI {
                time: t,
                id: event.id.clone(),
            });
        }
        self.events.insert(event.id, event);
    }

    pub fn call_arrival(&self, t: f32, cell: Cell) {}
}
